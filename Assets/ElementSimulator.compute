#pragma kernel Init
#pragma kernel ClearOutputTexture
#pragma kernel CacheParticlesInBins
#pragma kernel ComputeDensity
#pragma kernel ComputePressure
#pragma kernel ComputeHeat
#pragma kernel ApplyHeat
#pragma kernel ComputeForces
#pragma kernel Integrate

// solver parameters
static const float2 G = float2(0, 150 * -9.8); // external (gravitational) forces
static const float REST_DENS = 1500;// 300;// 1000; // rest density (basically repel, but slightly different)
static const float GAS_CONST = 20;// 500; // const for equation of state
static const float H = 4.0; // interaction radius
static const float HSQ = H * H; // radius^2 for optimization
static const float HSQ_TEMPERATURE = HSQ * 12.0; // interaction radius
static const float H_SURFACE_TENSION = H * 12.0; // interaction radius
static const float MASS = 128.0; // assume all particles have the same mass
static const float VISC = 8.0; // viscosity constant
static const float DT = 0.001;// 0.0008; // integration timestep
static const float DENSITY_OFFSET = 0.9;// 1.0;//0.825; // make SPIKY_GRAD apply force earlier (particles don't have to be as close)
static const float VISC_OFFSET = 1.0;//1.0;//0.825; // make VISC_LAP apply force earlier (particles don't have to be as close)
static const float PI = 3.14159265359;
// smoothing kernels defined in Müller and their gradients
static const float POLY6 = 315.0 / (65.0 * PI * pow(H, 9.0));
static const float SPIKY_GRAD = -45.0 / (PI * pow(H * DENSITY_OFFSET, 6.0));
static const float VISC_LAP = 45.0 / (PI * pow(H * VISC_OFFSET, 6.0));

// simulation parameters
static const float EPS = H; // boundary epsilon
static const float BOUND_DAMPING = -0.5;

static const float MAX_TEMPERATURE = 1000.0;

static const float THERMAL_DIFFUSIVITY = 0.1;
static const float REPEL_STRENGTH_MIN = 1.0;//10.0;
static const float REPEL_STRENGTH_MAX = 1.0;//40.0;
static const float REPEL_FACTOR_MIN = 1.0 / REPEL_STRENGTH_MAX;
static const float REPEL_FACTOR_MAX = 1.0 / REPEL_STRENGTH_MIN;
static const float CLUSTERING_RESISTANCE = 1.0;//20.0;
static const float SURFACE_TENSION_WATER = 25.0;

static const float STATE_CORRECTION_OFFSET = 0.000001; // offset to ensure two states can't be == 1 at the same time
static const float REPEL_STRENGTH_SMOOTHING_START_SOLID = 0.9;

static const float ALMOST_BUT_NOT_QUITE_ZERO = 0.00001; // used to prevent division by zero


//#region[rgba(80, 0, 0, 1)] | WARNING: shared with ElementSimulator.cs! must be equal!

static const int OUTPUT_THREAD_COUNT_X = 32;
static const int OUTPUT_THREAD_COUNT_Y = 32;

static const int BINS_THREAD_COUNT_X = 16;
static const int BINS_THREAD_COUNT_Y = 16;


static const int THREAD_COUNT_X = 64; // TODO: this can in theory go up to 1024 - make it happen!
static const uint PIXELS_PER_TILE_EDGE = 32;
static const uint GRID_WIDTH_TILES = 16;
static const uint GRID_HEIGHT_TILES =16;
static const uint GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const uint GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
static const uint BIN_SIZE = 8;
static const uint BIN_COUNT_X = GRID_WIDTH_PIXELS / BIN_SIZE;
static const uint BIN_COUNT_Y = GRID_HEIGHT_PIXELS / BIN_SIZE;
static const uint BIN_MAX_AMOUNT_OF_CONTENT = 16;
static const uint BIN_CLUSTER_SIZE = 5; // should be 9 but not sure how to fix
static const uint BIN_CLUSTER_CONTENT_MAX = BIN_CLUSTER_SIZE * BIN_MAX_AMOUNT_OF_CONTENT;
//#endregion


static const int ELEMENT_COUNT = 1;

static const float Mass[ELEMENT_COUNT] = { 
	MASS * 1.0 
};
static const float Viscosity[ELEMENT_COUNT] = {
	VISC * 1.0
};
static const float TemperatureFreezingPoint[ELEMENT_COUNT] = {
	273.15
};
static const float TemperatureBoilingPoint[ELEMENT_COUNT] = {
	373.15
};
static const float RepelStrengthSolid[ELEMENT_COUNT] = {
	1.75
};
static const float RepelStrengthLiquid[ELEMENT_COUNT] = {
	1.5
};
static const float RepelStrengthGas[ELEMENT_COUNT] = {
	2.0
};
static const float ThermalDiffusivitySolid[ELEMENT_COUNT] = {
	1.0
};
static const float ThermalDiffusivityLiquid[ELEMENT_COUNT] = {
	0.75
};
static const float ThermalDiffusivityGas[ELEMENT_COUNT] = {
	0.5
};


uint4 scale(uint4 f1, uint4 f2){
	return uint4(f1.x * f2.x, f1.y * f2.y, f1.z * f2.z, f1.w * f2.w);
}

int signNotZero(float f){
	int fSignActual = sign(f);
	return lerp(1, fSignActual, abs(fSignActual));
}

int sign01(float f){
	return clamp(sign(f), 0, 1);
}

int signAbs(float f){
	return abs(sign(f));
}

float PreventValueBeingZero(float f){
	return max(ALMOST_BUT_NOT_QUITE_ZERO, abs(f)) * signNotZero(f);
}

float2 PreventValueBeingZero(float2 f2){
	return float2(PreventValueBeingZero(f2.x), PreventValueBeingZero(f2.y));
}

struct Particle{ // WARNING: variables must correspond to ElementSimulator.cs's Particle
	float2 pos; // *
	float2 velocity; 
	float2 force;
	float density;
	float pressure;
	float temperature;
	float temperatureStartFrame;  // *
	float repelFactor;
	half isActive;  // *
	half4 particlesToHeat;
	half4 heatToGive;
	// half debugTemp;
	// half debugThermal;
	half debug1;
	half debug2;
	half debug3;
	half debug4;
	// half debug5;
	// half debug6;
	// half debug7;
	// half debug8;
	// half debug9;
	// half debug10;
	// half debug11;
	// half debug12;
	// half debug13;

	// 92 byte
	// half padding_0;
	// half padding_1;
	// half padding_2;
	// half padding_3;
	// half padding_4;
	// half padding_5;
	// half padding_6;
	// half padding_7;
	// half padding_8;
	// 128 byte

	uint binPosX;
	uint binPosY;
	uint elementIndex;  // *

	float GetMass()						{ return Mass[elementIndex]; }
	float GetViscosity()				{ return Viscosity[elementIndex]; }
	float GetFreezingPoint()			{ return TemperatureFreezingPoint[elementIndex]; }
	float GetBoilingPoint()				{ return TemperatureBoilingPoint[elementIndex]; }
	float GetRepelStrengthSolid()		{ return RepelStrengthSolid[elementIndex]; }
	float GetRepelStrengthLiquid()		{ return RepelStrengthLiquid[elementIndex]; }
	float GetRepelStrengthGas()			{ return RepelStrengthGas[elementIndex]; }
	float GetThermalDiffusivitySolid()	{ return ThermalDiffusivitySolid[elementIndex]; }
	float GetThermalDiffusivityLiquid()	{ return ThermalDiffusivityLiquid[elementIndex]; }
	float GetThermalDiffusivityGas()	{ return ThermalDiffusivityGas[elementIndex]; }
	
	float IsSolid() {
		return step(temperatureStartFrame, GetFreezingPoint() + STATE_CORRECTION_OFFSET);
	}

	float IsLiquid() {
		return step(temperatureStartFrame, GetBoilingPoint() - STATE_CORRECTION_OFFSET) - IsSolid();
	}

	float IsGas() {
		return step(GetBoilingPoint() - STATE_CORRECTION_OFFSET, temperatureStartFrame);
	}

	float GetThermalDiffusivity() {
		return THERMAL_DIFFUSIVITY * ((IsSolid() * GetThermalDiffusivitySolid()) + (IsLiquid() * GetThermalDiffusivityLiquid()) + (IsGas() * GetThermalDiffusivityGas()));
	}

	float GetRepelStrengthCurrent()	{ 
		return IsSolid() * GetRepelStrengthSolid() + IsLiquid() * GetRepelStrengthLiquid() + IsGas() * GetRepelStrengthGas(); 
	}

	void SetTemperature(float temp){
		temperature = temp;// clamp(temp, 0.0, MAX_TEMPERATURE);

		float isSolid = IsSolid();
		float isLiquid = IsLiquid();
		float isGas = IsGas();

		float repelStrengthSolid = GetRepelStrengthSolid();
		float repelStrengthLiquid = GetRepelStrengthLiquid();
		float repelStrengthGas = GetRepelStrengthGas();

		// to prevent melting causing explosions, lerp the repelstrength
		float repelStrengthSmoothedSolidToLiquid = lerp(repelStrengthSolid, repelStrengthLiquid, clamp((temp - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetFreezingPoint() - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID), 0, 1));
		float repelStrengthSmoothedLiquidToGas = lerp(repelStrengthLiquid, repelStrengthGas, clamp((temp - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetBoilingPoint() - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID), 0, 1));

		// each state has a fixed strength, but gas continues the more temperature increases
		repelFactor = 0.0;
		repelFactor += (1.0 / repelStrengthSmoothedSolidToLiquid) * isSolid;
		repelFactor += (1.0 / repelStrengthSmoothedLiquidToGas) * isLiquid;
		repelFactor += (1.0 / repelStrengthGas) * isGas;

		float extraRepelFactor = 1.0 / clamp(max(REPEL_STRENGTH_MIN, temperature / MAX_TEMPERATURE * REPEL_STRENGTH_MAX), REPEL_STRENGTH_MIN, REPEL_STRENGTH_MAX);
		repelFactor += (extraRepelFactor - repelFactor) * isGas;

		repelFactor = clamp(repelFactor, REPEL_FACTOR_MIN, REPEL_FACTOR_MAX); // just a safeguard
	}
};

// struct DebugVars{ // WARNING: variables must correspond to ElementSimulator.compute's Particle!
// 	half2 debugID;
// 	half debug_00;
// 	half debug_01;
// 	half debug_02;
// 	half debug_03;
// 	half debug_04;
// 	half debug_05;
// 	half debug_06;
// 	half debug_07;
// 	half debug_08;
// 	half debug_09;
// 	half debug_10;
// 	half debug_11;
// 	half debug_12;
// 	half debug_13;
// 	half debug_14;

// 	void SetID(half id1, half id2){
// 		debugID.x = id1;
// 		debugID.y = id2;
// 	}

// 	void Set(uint index, float val){
// 		if(index == 0) debug_00 = val;
// 		else if(index == 1) debug_01 = val;
// 		else if(index == 2) debug_02 = val;
// 		else if(index == 3) debug_03 = val;
// 		else if(index == 4) debug_04 = val;
// 		else if(index == 5) debug_05 = val;
// 		else if(index == 6) debug_06 = val;
// 		else if(index == 7) debug_07 = val;
// 		else if(index == 8) debug_08 = val;
// 		else if(index == 9) debug_09 = val;
// 		else if(index == 10) debug_10 = val;
// 		else if(index == 11) debug_11 = val;
// 		else if(index == 12) debug_12 = val;
// 		else if(index == 13) debug_13 = val;
// 		else if(index == 14) debug_14 = val;
// 		//else hasNewValue = 0;
// 	}
// };


RWStructuredBuffer<Particle> particles;
uniform uint particleCount;
// uniform int debugBinIndexX;
// uniform int debugBinIndexY;
// RWStructuredBuffer<DebugVars> debugVars;

RWTexture2D<half> binsDirty;
RWTexture2D<half> binLoads;
RWTexture2D<uint4> bins_00;
RWTexture2D<uint4> bins_01;
RWTexture2D<uint4> bins_02;
RWTexture2D<uint4> bins_03;

RWTexture2D<float4> output;
half isFirstFrame;

uint GetBinPosX(float2 pos) {
	return floor(pos.x / BIN_SIZE);
}

uint GetBinPosY(float2 pos) {
	return floor(pos.y / BIN_SIZE);
}

void GetParticlesInBin(uint2 binPos, out uint binLoad, out uint binParticles[BIN_MAX_AMOUNT_OF_CONTENT]){
	binLoad = round(binLoads.Load(binPos) * BIN_MAX_AMOUNT_OF_CONTENT);

	uint zero = 0;
	binParticles[0] = zero;
	binParticles[1] = zero;
	binParticles[2] = zero;
	binParticles[3] = zero;
	binParticles[4] = zero;
	binParticles[5] = zero;
	binParticles[6] = zero;
	binParticles[7] = zero;
	binParticles[8] = zero;
	binParticles[9] = zero;
	binParticles[10] = zero;
	binParticles[11] = zero;
	
	uint4 binContents;
	if(binLoad > 0){
		binContents = round(bins_00.Load(binPos));
		binParticles[0] = binContents.x;
		binParticles[1] = binContents.y;
		binParticles[2] = binContents.z;
		binParticles[3] = binContents.w;
	}
	if(binLoad > 4){
		binContents = round(bins_01.Load(binPos));
		binParticles[4] = binContents.x;
		binParticles[5] = binContents.y;
		binParticles[6] = binContents.z;
		binParticles[7] = binContents.w;
	}
	if(binLoad > 8){
		binContents = round(bins_02.Load(binPos));
		binParticles[8] = binContents.x;
		binParticles[9] = binContents.y;
		binParticles[10] = binContents.z;
		binParticles[11] = binContents.w;
	}
	if(binLoad > 12){
		binContents = round(bins_03.Load(binPos));
		binParticles[12] = binContents.x;
		binParticles[13] = binContents.y;
		binParticles[14] = binContents.z;
		binParticles[15] = binContents.w;
	}
}

void AddParticlesFromBinToCluster(uint2 binPos, inout uint clusterLoad, inout uint clusterContent[BIN_CLUSTER_CONTENT_MAX]){
	uint binLoad;
	uint binContents[BIN_MAX_AMOUNT_OF_CONTENT];
	GetParticlesInBin(binPos, binLoad, binContents);
	for(uint i = 0; i < binLoad; i++, clusterLoad++){
		clusterContent[clusterLoad] = binContents[i];
	} 
}

void GetNeighboringParticles(int particleIndex, uint2 binPos, out uint clusterLoad, out uint clusterContent[BIN_CLUSTER_CONTENT_MAX]){

	// optimization: try seeing if this gets slower or faster with ifs

	uint2 binPos_L = uint2(clamp(binPos.x - 1, 0, BIN_COUNT_X - 1), binPos.y);
	uint2 binPos_R = uint2(clamp(binPos.x + 1, 0, BIN_COUNT_X - 1), binPos.y);
	uint2 binPos_B = uint2(binPos.x, clamp(binPos.y - 1, 0, BIN_COUNT_Y - 1));
	uint2 binPos_T = uint2(binPos.x, clamp(binPos.y + 1, 0, BIN_COUNT_Y - 1));
	uint2 binPos_BL = uint2(binPos_L.x, binPos_B.y);
	uint2 binPos_TL = uint2(binPos_L.x, binPos_T.y);
	uint2 binPos_TR = uint2(binPos_R.x, binPos_T.y);
	uint2 binPos_BR = uint2(binPos_R.x, binPos_B.y);

	clusterLoad = 0;
	AddParticlesFromBinToCluster(binPos, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_L, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_R, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_T, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_B, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_BL, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_BR, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_TR, clusterLoad, clusterContent);
	AddParticlesFromBinToCluster(binPos_TL, clusterLoad, clusterContent);

	for(uint i = clusterLoad; i < BIN_CLUSTER_CONTENT_MAX; i++){
		clusterContent[i] = 0;
	}
}

// called once
[numthreads(THREAD_COUNT_X, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	particle.binPosX = GetBinPosX(particle.pos);
	particle.binPosY = GetBinPosY(particle.pos);
	particle.SetTemperature(particle.temperatureStartFrame);
	particles[id.x] = particle;
}

// called continuosly
[numthreads(OUTPUT_THREAD_COUNT_X, OUTPUT_THREAD_COUNT_Y, 1)]
void ClearOutputTexture(uint3 id : SV_DispatchThreadID) {
	output[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
}

[numthreads(BINS_THREAD_COUNT_X, BINS_THREAD_COUNT_Y, 1)]
void CacheParticlesInBins(uint3 id : SV_DispatchThreadID){
	half isDirty = max(isFirstFrame, binsDirty.Load(id.xy));
	binsDirty[id.xy] = 0.0;
	if(isDirty == 0){
		return;
	}

	half binLoad = 0;
	half binContent[BIN_MAX_AMOUNT_OF_CONTENT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

	for(uint i = 0; i < particleCount; i++){ // TODO: can we skip particles that have already found their bin?
		Particle particle = particles[i];

		if(particle.binPosX == id.x && particle.binPosY == id.y){
			binContent[binLoad] = i;
			binLoad = min(binLoad + 1, BIN_MAX_AMOUNT_OF_CONTENT);
			particles[i] = particle;
		}

		// TODO: check if this improves things (needs a lot of density though)
		// if(binLoad >= BIN_MAX_AMOUNT_OF_CONTENT){
		// 	break;
		// }
	}

	binLoads[id.xy] = binLoad / half(BIN_MAX_AMOUNT_OF_CONTENT);
	
	uint4 binContent_00 = uint4(
		binContent[0],
		binContent[1],
		binContent[2],
		binContent[3]
	);
	bins_00[id.xy] = binContent_00;
	
	uint4 binContent_01 = uint4(
		binContent[4],
		binContent[5],
		binContent[6],
		binContent[7]
	);
	bins_01[id.xy] = binContent_01;

	uint4 binContent_02 = uint4(
		binContent[8],
		binContent[9],
		binContent[10],
		binContent[11]
	);
	bins_02[id.xy] = binContent_02;

	uint4 binContent_03 = uint4(
		binContent[12],
		binContent[13],
		binContent[14],
		binContent[15]
	);
	bins_03[id.xy] = binContent_03;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(id.x, uint2(particle.binPosX, particle.binPosY), clusterLoad, clusterContents);

	particle.density = particle.GetMass() * POLY6 * pow(HSQ, 2.0);
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];
		float2 dir = otherParticle.pos - particle.pos;
		float r2 = (dir.x * dir.x + dir.y * dir.y) * max(particle.repelFactor, otherParticle.repelFactor);

		half areParticlesDifferent = signAbs(id.x - neighborIndex);
		half shouldApplyDensity = areParticlesDifferent * step(r2, HSQ);
		particle.density += shouldApplyDensity * otherParticle.GetMass() * POLY6 * pow(HSQ - r2, 2.0);
	}

	particles[id.x] = particle;
	
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputePressure(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	particle.pressure = particle.isActive * GAS_CONST * (particle.density - REST_DENS);
	particle.debug1 = particle.density;
	particle.debug2 = particle.pressure;
	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeHeat(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(id.x, uint2(particle.binPosX, particle.binPosY), clusterLoad, clusterContents);

	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];
		float2 dir = otherParticle.pos - particle.pos;
		float r2 = (dir.x * dir.x + dir.y * dir.y) * max(particle.repelFactor, otherParticle.repelFactor);

		half areParticlesDifferent = signAbs(id.x - neighborIndex);
		half shouldApplyDensity = areParticlesDifferent * step(r2, HSQ);

		half temperatureStartFrame = particle.temperatureStartFrame;
		half temperatureStartFrameOther = otherParticle.temperatureStartFrame;
		
		half isWithinRange = step(r2, HSQ_TEMPERATURE);
		half isWarmerThanNeighbor = step(temperatureStartFrameOther, temperatureStartFrame);
		half isNeighborBelowMaxHeat = step(otherParticle.temperatureStartFrame, MAX_TEMPERATURE);
		half shouldApplyTemperature = isWarmerThanNeighbor * areParticlesDifferent * isWithinRange * isNeighborBelowMaxHeat;

		half thermalDiffusivity = (particle.GetThermalDiffusivity() + otherParticle.GetThermalDiffusivity()) * 0.5;
		half exchangeGive = shouldApplyTemperature * (temperatureStartFrame - temperatureStartFrameOther) * thermalDiffusivity;

		half4 particlesToHeat = particle.particlesToHeat;
		half4 heatToGive = particle.heatToGive; 

		if(exchangeGive > heatToGive.w){
			heatToGive.x = heatToGive.y;
			heatToGive.y = heatToGive.z;
			heatToGive.z = heatToGive.w;
			heatToGive.w = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = particlesToHeat.z;
			particlesToHeat.z = particlesToHeat.w;
			particlesToHeat.w = neighborIndex;
		}
		else if(exchangeGive > heatToGive.z){
			heatToGive.x = heatToGive.y;
			heatToGive.y = heatToGive.z;
			heatToGive.z = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = particlesToHeat.z;
			particlesToHeat.z = neighborIndex;
		}
		else if(exchangeGive > heatToGive.y){
			heatToGive.x = heatToGive.y;
			heatToGive.y = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = neighborIndex;
		}
		else if(exchangeGive > heatToGive.x){
			heatToGive.x = exchangeGive;
			particlesToHeat.x = neighborIndex;
		}

		particle.particlesToHeat = particlesToHeat;
		particle.heatToGive = heatToGive;
	}

	// clamp components
	half4 heatToGive = particle.heatToGive;
	half heat = particle.temperatureStartFrame;
	heatToGive.x = min(heatToGive.x, heat);
	heatToGive.y = min(heatToGive.y, heat - heatToGive.x);
	heatToGive.z = min(heatToGive.z, heat - (heatToGive.x + heatToGive.y));
	heatToGive.w = min(heatToGive.w, heat - (heatToGive.x + heatToGive.y + heatToGive.z));
	
	particle.heatToGive = heatToGive;

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ApplyHeat(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(id.x, uint2(particle.binPosX, particle.binPosY), clusterLoad, clusterContents);

	half heat = particle.temperatureStartFrame;
	
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];

		uint4 othersParticlesToHeat = otherParticle.particlesToHeat;
		half isParticleX = 1 - signAbs(othersParticlesToHeat.x - id.x);
		half isParticleY = 1 - signAbs(othersParticlesToHeat.y - id.x);
		half isParticleZ = 1 - signAbs(othersParticlesToHeat.z - id.x);
		half isParticleW = 1 - signAbs(othersParticlesToHeat.w - id.x);

		half4 othersHeatToGive = otherParticle.heatToGive; 
		heat += othersHeatToGive.x * isParticleX;
		heat += othersHeatToGive.y * isParticleY;
		heat += othersHeatToGive.z * isParticleZ;
		heat += othersHeatToGive.w * isParticleW;
	}

	half4 heatToGive = particle.heatToGive;
	particle.SetTemperature(heat - (heatToGive.x + heatToGive.y + heatToGive.z + heatToGive.w));

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	float2 fpress = float2(0.0, 0.0);
	float2 fvisc = float2(0.0, 0.0);
	float2 fsurftens = float2(0.0, 0.0);
	float2 fgrav = G * particle.density;
	
	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(id.x, uint2(particle.binPosX, particle.binPosY), clusterLoad, clusterContents);

	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];
	
		Particle otherParticle = particles[neighborIndex];

		float2 diff = PreventValueBeingZero(otherParticle.pos - particle.pos);
		float2 diffNormal = normalize(diff);

		float r = sqrt(diff.x * diff.x + diff.y * diff.y) * max(particle.repelFactor, otherParticle.repelFactor);

		uint areParticlesDifferent = signAbs(id.x - neighborIndex);
		uint isTouchingNeighbor = step(r, H);
		uint shouldApplyAnything = isTouchingNeighbor * areParticlesDifferent * particle.isActive * otherParticle.isActive;

		// compute pressure force contribution
		fpress += shouldApplyAnything * -diffNormal * otherParticle.GetMass() * (particle.pressure + otherParticle.pressure) / (2.0 * otherParticle.density) * SPIKY_GRAD * pow(H - r, 2.0) * CLUSTERING_RESISTANCE;
		// compute viscosity force contribution
		fvisc += shouldApplyAnything * otherParticle.GetViscosity() * otherParticle.GetMass() * (otherParticle.velocity - particle.velocity) / otherParticle.density * VISC_LAP * (H - r);
		
		float shouldApplySurfaceTension = shouldApplyAnything * floor((step(r, H_SURFACE_TENSION) + particle.IsLiquid()) * 0.5);
		fsurftens += shouldApplySurfaceTension * diffNormal * VISC_LAP * SURFACE_TENSION_WATER;

		// bounce off frozen particles
		float shouldApplyBounce = shouldApplyAnything * floor((isTouchingNeighbor + otherParticle.IsSolid()) / 2.0);
		particle.velocity *= lerp(1.0, diffNormal * BOUND_DAMPING, shouldApplyBounce);
	}

	particle.force = particle.isActive * (fpress + fvisc + fsurftens + fgrav);

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	particle.force.x = PreventValueBeingZero(particle.force.x);
	particle.force.y = PreventValueBeingZero(particle.force.y);
	particle.density = PreventValueBeingZero(particle.density);

	// forward Euler integration
	particle.velocity += DT * (particle.force / particle.density);
	particle.pos += DT * particle.velocity;

	// if(isFirstFrame) particle.velocity += (particle.force / particle.GetMass()) * DT * 0.5;
	// particle.pos += DT * particle.velocity;
	// float2 acceleration = particle.force / particle.GetMass();
	// particle.velocity += DT * acceleration;

	float oldX = particle.pos.x;
	float oldY = particle.pos.y;
	particle.pos.x = clamp(particle.pos.x, EPS, GRID_WIDTH_PIXELS - EPS);
	particle.pos.y = clamp(particle.pos.y, EPS, GRID_HEIGHT_PIXELS - EPS);

	particle.velocity.x *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.x - oldX)), 0, 1));
	particle.velocity.y *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.y - oldY)), 0, 1));
	// velocity = particle.velocity;

	float temp = (particle.temperature / MAX_TEMPERATURE) * 3.0;
	// output[particle.pos] = float4(temp, 0, 1 - temp, particle.isActive);
	output[particle.pos] = float4(0, 0, 0, 1);

	 // for next frame
	uint oldBinPosX = particle.binPosX;
	uint oldBinPosY = particle.binPosY; 
	particle.binPosX = GetBinPosX(particle.pos);
	particle.binPosY = GetBinPosY(particle.pos);
	half isDirty = clamp(signAbs(particle.binPosX - oldBinPosX) + signAbs(particle.binPosY - oldBinPosY), 0.0, 1.0);
	if(isDirty){ // TODO: is it better/worse to assign this inside an if-statement?
		binsDirty[uint2(oldBinPosX, oldBinPosY)] = 1.0;
		binsDirty[uint2(particle.binPosX, particle.binPosY)] = 1.0;
	}

	particle.temperatureStartFrame = particle.temperature;
	particle.particlesToHeat.xyzw = 0.0;
	particle.heatToGive.xyzw = 0.0;

	particles[id.x] = particle;
}