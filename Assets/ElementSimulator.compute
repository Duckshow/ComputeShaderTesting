#pragma kernel Init
#pragma kernel InitBins
#pragma kernel CacheBinStates
#pragma kernel ClearOutputTexture
#pragma kernel CacheParticlesInBins
#pragma kernel CacheParticleNeighbors
#pragma kernel ComputeDensity
#pragma kernel ComputePressure
#pragma kernel ComputeHeat
#pragma kernel ApplyHeat
#pragma kernel ComputeForces
#pragma kernel Integrate
#pragma kernel MarkPixelsForPostProcess
#pragma kernel PostProcess

static const uint HIGHEST_VALUE_16BIT = 32768;

// solver parameters
static const float2 G = float2(0, 150 * -9.8); // external (gravitational) forces
static const float REST_DENS = 1500;// 300;// 1000; // rest density (basically repel, but slightly different)
static const float GAS_CONST = 20;// 500; // const for equation of state
static const float H = 4.0; // interaction radius
static const float HSQ = H * H; // radius^2 for optimization
static const float HSQ_TEMPERATURE = HSQ * 12.0; // interaction radius
static const float H_SURFACE_TENSION = H * 12.0; // interaction radius
static const float MASS = 128.0; // assume all particles have the same mass
static const float VISC = 6.0; // viscosity constant
static const float DT = 0.001;// 0.0008; // integration timestep
static const float DENSITY_OFFSET = 0.9;// 1.0;//0.825; // make SPIKY_GRAD apply force earlier (particles don't have to be as close)
static const float VISC_OFFSET = 0.8;//1.0;//1.0;//0.825; // make VISC_LAP apply force earlier (particles don't have to be as close)
static const float PI = 3.14159265359;
// smoothing kernels defined in Müller and their gradients
static const float POLY6 = 315.0 / (65.0 * PI * pow(H, 9.0));
static const float SPIKY_GRAD = -45.0 / (PI * pow(H * DENSITY_OFFSET, 6.0));
static const float VISC_LAP = 45.0 / (PI * pow(H * VISC_OFFSET, 6.0));

// simulation parameters
static const float EPS = H; // boundary epsilon
static const float BOUND_DAMPING = -0.5;

static const float MAX_TEMPERATURE = 1000.0;

static const float THERMAL_DIFFUSIVITY = 0.1;
static const float REPEL_STRENGTH_MIN = 1.5;//10.0;
static const float REPEL_STRENGTH_MAX = 20.0;//20.0;//40.0;
static const float REPEL_FACTOR_MIN = 1.0 / REPEL_STRENGTH_MAX;
static const float REPEL_FACTOR_MAX = 1.0 / REPEL_STRENGTH_MIN;
static const float CLUSTERING_RESISTANCE = 1.0;//20.0;
static const float SURFACE_TENSION_WATER = 1.0;//250.0; // TODO: doesn't appear to work??

static const float STATE_CORRECTION_OFFSET = 0.000001; // offset to ensure two states can't be == 1 at the same time
static const float REPEL_STRENGTH_SMOOTHING_START_SOLID = 0.9;

static const float ALMOST_BUT_NOT_QUITE_ZERO = 0.00001; // used to prevent division by zero


//#region[rgba(80, 0, 0, 1)] | WARNING: shared with ElementSimulator.cs! must be equal!

static const int OUTPUT_THREAD_COUNT_X = 32;
static const int OUTPUT_THREAD_COUNT_Y = 32;
static const int POSTPROCESS_THREAD_COUNT_X = 8;
static const int POSTPROCESS_THREAD_COUNT_Y = 8;

static const int BINS_THREAD_COUNT = 32;

static const int THREAD_COUNT_X = 64; // TODO: this can in theory go up to 1024 - make it happen!
static const uint PIXELS_PER_TILE_EDGE = 32;
static const uint GRID_WIDTH_TILES = 16;
static const uint GRID_HEIGHT_TILES = 16;
static const uint GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const uint GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
static const uint BIN_SIZE = 8;
static const uint BIN_COUNT_X = GRID_WIDTH_PIXELS / BIN_SIZE;
static const uint BIN_COUNT_Y = GRID_HEIGHT_PIXELS / BIN_SIZE;
static const uint BIN_MAX_AMOUNT_OF_CONTENT = 16;
static const uint BIN_CLUSTER_SIZE = 9; // should be 9 but not sure how to fix
static const uint BIN_CLUSTER_CONTENT_MAX = BIN_CLUSTER_SIZE * BIN_MAX_AMOUNT_OF_CONTENT;
//#endregion

static const uint BIN_PIXEL_COUNT = BIN_SIZE * BIN_SIZE;


static const int ELEMENT_COUNT = 1;

static const float Mass[ELEMENT_COUNT] = { 
	MASS * 1.0 
};
static const float Viscosity[ELEMENT_COUNT] = {
	VISC * 1.0
};
static const float TemperatureFreezingPoint[ELEMENT_COUNT] = {
	273.15
};
static const float TemperatureBoilingPoint[ELEMENT_COUNT] = {
	373.15
};
static const float RepelStrengthSolid[ELEMENT_COUNT] = {
	1.75
};
static const float RepelStrengthLiquid[ELEMENT_COUNT] = {
	1.5
};
static const float RepelStrengthGas[ELEMENT_COUNT] = {
	2.0
};
static const float ThermalDiffusivitySolid[ELEMENT_COUNT] = {
	1.0
};
static const float ThermalDiffusivityLiquid[ELEMENT_COUNT] = {
	0.75
};
static const float ThermalDiffusivityGas[ELEMENT_COUNT] = {
	0.5
};


uint4 scale(uint4 f1, uint4 f2){
	return uint4(f1.x * f2.x, f1.y * f2.y, f1.z * f2.z, f1.w * f2.w);
}

int signNotZero(float f){
	int fSignActual = sign(f);
	return lerp(1, fSignActual, abs(fSignActual));
}

int sign01(float f){
	return clamp(sign(f), 0, 1);
}

int signAbs(float f){
	return abs(sign(f));
}

float PreventValueBeingZero(float f){
	return max(ALMOST_BUT_NOT_QUITE_ZERO, abs(f)) * signNotZero(f);
}

float2 PreventValueBeingZero(float2 f2){
	return float2(PreventValueBeingZero(f2.x), PreventValueBeingZero(f2.y));
}

struct Bin{ // WARNING: variables must correspond to ElementSimulator.cs's Bin!
	uint id;
	uint posX;
	uint posY;
	uint isDirty;
	uint load;
	uint contents[BIN_MAX_AMOUNT_OF_CONTENT];
};

struct Particle{ // WARNING: variables must correspond to ElementSimulator.cs's Particle
	float2 pos; // *
	float2 velocity; 
	float2 force;
	float density;
	float pressure;
	float temperature;
	float temperatureStartFrame;  // *
	float repelFactor;
	half isActive;  // *
	half4 particlesToHeat;
	half4 heatToGive;
	half debugTemp;
	// half debugThermal;
	half debug1;
	half debug2;
	half debug3;
	half debug4;
	half debug5;
	half debug6;
	half debug7;
	half debug8;
	half debug9;
	half debug10;
	half debug11;
	half debug12;
	half debug13;

	// 92 byte
	// half padding_0;
	// half padding_1;
	// half padding_2;
	// half padding_3;
	// half padding_4;
	// half padding_5;
	// half padding_6;
	// half padding_7;
	// half padding_8;
	// 128 byte

	uint elementIndex;  // *

	uint binID;
	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];


	float GetMass()						{ return Mass[elementIndex]; }
	float GetViscosity()				{ return Viscosity[elementIndex]; }
	float GetFreezingPoint()			{ return TemperatureFreezingPoint[elementIndex]; }
	float GetBoilingPoint()				{ return TemperatureBoilingPoint[elementIndex]; }
	float GetRepelStrengthSolid()		{ return RepelStrengthSolid[elementIndex]; }
	float GetRepelStrengthLiquid()		{ return RepelStrengthLiquid[elementIndex]; }
	float GetRepelStrengthGas()			{ return RepelStrengthGas[elementIndex]; }
	float GetThermalDiffusivitySolid()	{ return ThermalDiffusivitySolid[elementIndex]; }
	float GetThermalDiffusivityLiquid()	{ return ThermalDiffusivityLiquid[elementIndex]; }
	float GetThermalDiffusivityGas()	{ return ThermalDiffusivityGas[elementIndex]; }
	
	float IsSolid() {
		return step(temperatureStartFrame, GetFreezingPoint() + STATE_CORRECTION_OFFSET);
	}

	float IsLiquid() {
		return step(temperatureStartFrame, GetBoilingPoint() - STATE_CORRECTION_OFFSET) - IsSolid();
	}

	float IsGas() {
		return step(GetBoilingPoint() - STATE_CORRECTION_OFFSET, temperatureStartFrame);
	}

	float GetThermalDiffusivity() {
		return THERMAL_DIFFUSIVITY * ((IsSolid() * GetThermalDiffusivitySolid()) + (IsLiquid() * GetThermalDiffusivityLiquid()) + (IsGas() * GetThermalDiffusivityGas()));
	}

	float GetRepelStrengthCurrent()	{ 
		return IsSolid() * GetRepelStrengthSolid() + IsLiquid() * GetRepelStrengthLiquid() + IsGas() * GetRepelStrengthGas(); 
	}

	void SetTemperature(float temp){
		temperature = temp;// clamp(temp, 0.0, MAX_TEMPERATURE);

		float isSolid = IsSolid();
		float isLiquid = IsLiquid();
		float isGas = IsGas();

		float repelStrengthSolid = GetRepelStrengthSolid();
		float repelStrengthLiquid = GetRepelStrengthLiquid();
		float repelStrengthGas = GetRepelStrengthGas();

		// to prevent melting causing explosions, lerp the repelstrength
		float repelStrengthSmoothedSolidToLiquid = lerp(repelStrengthSolid, repelStrengthLiquid, clamp((temp - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetFreezingPoint() - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID), 0, 1));
		float repelStrengthSmoothedLiquidToGas = lerp(repelStrengthLiquid, repelStrengthGas, clamp((temp - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetBoilingPoint() - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID), 0, 1));

		// each state has a fixed strength, but gas continues the more temperature increases
		repelFactor = 0.0;
		repelFactor += (1.0 / repelStrengthSmoothedSolidToLiquid) * isSolid;
		repelFactor += (1.0 / repelStrengthSmoothedLiquidToGas) * isLiquid;
		repelFactor += (1.0 / repelStrengthGas) * isGas;

		float extraRepelFactor = 1.0 / clamp(max(REPEL_STRENGTH_MIN, temperature / MAX_TEMPERATURE * REPEL_STRENGTH_MAX), REPEL_STRENGTH_MIN, REPEL_STRENGTH_MAX);
		repelFactor += (extraRepelFactor - repelFactor) * isGas;

		repelFactor = clamp(repelFactor, REPEL_FACTOR_MIN, REPEL_FACTOR_MAX); // just a safeguard
	}
};

// struct DebugVars{ // WARNING: variables must correspond to ElementSimulator.cs's DebugVars!
// 	half hasNewValue;
// 	half2 debugID;
// 	half debug_00;
// 	half debug_01;
// 	half debug_02;
// 	half debug_03;
// 	half debug_04;
// 	half debug_05;
// 	half debug_06;
// 	half debug_07;
// 	half debug_08;
// 	half debug_09;
// 	half debug_10;
// 	half debug_11;
// 	half debug_12;
// 	half debug_13;
// 	half debug_14;
// 	half debug_15;
// 	half debug_16;
// 	half debug_17;
// 	half debug_18;
// 	half debug_19;
// 	half debug_20;
// 	half debug_21;
// 	half debug_22;
// 	half debug_23;
// 	half debug_24;
// 	half debug_25;
// 	half debug_26;
// 	half debug_27;
// 	half debug_28;
// 	half debug_29;
// 	half debug_30;
// 	half debug_31;
// 	half debug_32;
// 	half debug_33;
// 	half debug_34;
// 	half debug_35;
// 	half debug_36;
// 	half debug_37;
// 	half debug_38;
// 	half debug_39;
// 	half debug_40;
// 	half debug_41;
// 	half debug_42;
// 	half debug_43;
// 	half debug_44;
// 	half debug_45;
// 	half debug_46;
// 	half debug_47;
// 	half debug_48;
// 	half debug_49;

// 	void SetID(half id1, half id2){
// 		debugID.x = id1;
// 		debugID.y = id2;
// 	}

// 	void Set(uint index, float val){
// 		hasNewValue = 1;

// 		if(index == 0) debug_00 = val;
// 		else if(index == 1) debug_01 = val;
// 		else if(index == 2) debug_02 = val;
// 		else if(index == 3) debug_03 = val;
// 		else if(index == 4) debug_04 = val;
// 		else if(index == 5) debug_05 = val;
// 		else if(index == 6) debug_06 = val;
// 		else if(index == 7) debug_07 = val;
// 		else if(index == 8) debug_08 = val;
// 		else if(index == 9) debug_09 = val;
// 		else if(index == 10) debug_10 = val;
// 		else if(index == 11) debug_11 = val;
// 		else if(index == 12) debug_12 = val;
// 		else if(index == 13) debug_13 = val;
// 		else if(index == 14) debug_14 = val;
// 		else if(index == 15) debug_15 = val;
// 		else if(index == 16) debug_16 = val;
// 		else if(index == 17) debug_17 = val;
// 		else if(index == 18) debug_18 = val;
// 		else if(index == 19) debug_19 = val;
// 		else if(index == 20) debug_20 = val;
// 		else if(index == 21) debug_21 = val;
// 		else if(index == 22) debug_22 = val;
// 		else if(index == 23) debug_23 = val;
// 		else if(index == 24) debug_24 = val;
// 		else if(index == 25) debug_25 = val;
// 		else if(index == 26) debug_26 = val;
// 		else if(index == 27) debug_27 = val;
// 		else if(index == 28) debug_28 = val;
// 		else if(index == 29) debug_29 = val;
// 		else if(index == 30) debug_30 = val;
// 		else if(index == 31) debug_31 = val;
// 		else if(index == 31) debug_31 = val;
// 		else if(index == 32) debug_32 = val;
// 		else if(index == 33) debug_33 = val;
// 		else if(index == 34) debug_34 = val;
// 		else if(index == 35) debug_35 = val;
// 		else if(index == 36) debug_36 = val;
// 		else if(index == 37) debug_37 = val;
// 		else if(index == 38) debug_38 = val;
// 		else if(index == 39) debug_39 = val;
// 		else if(index == 40) debug_40 = val;
// 		else if(index == 41) debug_41 = val;
// 		else if(index == 41) debug_41 = val;
// 		else if(index == 42) debug_42 = val;
// 		else if(index == 43) debug_43 = val;
// 		else if(index == 44) debug_44 = val;
// 		else if(index == 45) debug_45 = val;
// 		else if(index == 46) debug_46 = val;
// 		else if(index == 47) debug_47 = val;
// 		else if(index == 48) debug_48 = val;
// 		else if(index == 49) debug_49 = val;
// 	}
// };


RWStructuredBuffer<Bin> bins;
RWStructuredBuffer<Bin> binsAtStartFrame;
RWStructuredBuffer<Particle> particles;
uniform uint particleCount;
// uniform int debugBinIndexX;
// uniform int debugBinIndexY;
// RWStructuredBuffer<DebugVars> debugVars;

RWTexture2D<float4> output;
uniform bool isFirstFrame;
uniform bool isEvenFrame;
half abort;
uniform uint debugIndex;


uint ConvertPosToBinPosX(float x) {
	return floor(x / BIN_SIZE);
}

uint ConvertPosToBinPosY(float y) {
	return floor(y / BIN_SIZE);
}

uint ConvertBinIDToBinPosX(uint id){
	return id % BIN_COUNT_X;
}

uint ConvertBinIDToBinPosY(uint id){
	return floor(id / BIN_COUNT_Y);
}

uint GetBinIDFromBinPos(uint x, uint y){
	return y * BIN_COUNT_X + x;
}

uint GetBinIDFromPos(uint2 pos){
	uint binPosX = ConvertPosToBinPosX(pos.x);
	uint binPosY = ConvertPosToBinPosY(pos.y);
	return binPosY * BIN_COUNT_X + binPosX;
}

void GetNeighboringParticles(uint binPosX, uint binPosY, bool willWriteToBins, out uint clusterLoad, out uint clusterContents[BIN_CLUSTER_CONTENT_MAX]){
	uint binIDs[BIN_CLUSTER_SIZE] = {
		GetBinIDFromBinPos(binPosX, binPosY),
		GetBinIDFromBinPos(binPosX - 1, binPosY),
		GetBinIDFromBinPos(binPosX + 1, binPosY),
		GetBinIDFromBinPos(binPosX, binPosY - 1),
		GetBinIDFromBinPos(binPosX, binPosY + 1),
		GetBinIDFromBinPos(binPosX - 1, binPosY - 1),
		GetBinIDFromBinPos(binPosX - 1, binPosY + 1),
		GetBinIDFromBinPos(binPosX + 1, binPosY + 1),
		GetBinIDFromBinPos(binPosX + 1, binPosY - 1),
	};

	uint safetyModLeft = signAbs(binPosX);
	uint safetyModRight = signAbs(BIN_COUNT_X - 1 - binPosX);
	uint safetyModDown = signAbs(binPosY);
	uint safetyModUp = signAbs(BIN_COUNT_Y - 1 - binPosY);
	uint binIDsSafetyMods[BIN_CLUSTER_SIZE] = {
		1,
		safetyModLeft,
		safetyModRight,
		safetyModDown,
		safetyModUp,
		safetyModLeft * safetyModDown,
		safetyModLeft * safetyModUp,
		safetyModRight * safetyModUp,
		safetyModRight * safetyModDown
	};

	Bin bin;
	uint binLoad;
	uint binContents[BIN_MAX_AMOUNT_OF_CONTENT];
	uint totalIndex = 0;
	uint binID;

	clusterLoad = 0;
	for(uint binIndex = 0; binIndex < BIN_CLUSTER_SIZE; binIndex++){
		binID = binIDs[binIndex];
		if(willWriteToBins) {
			bin = binsAtStartFrame[binID];
		}
		else {
			bin = bins[binID];
		} 

		binLoad = bin.load * binIDsSafetyMods[binIndex];
		binContents = bin.contents;

		for(uint contentIndex = 0; contentIndex < binLoad; contentIndex++){
			clusterContents[totalIndex] = binContents[contentIndex];
			clusterLoad += 1;
			totalIndex += 1;
		}
	}
}

// called once
[numthreads(THREAD_COUNT_X, 1, 1)]
void Init(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	particle.binID = GetBinIDFromPos(particle.pos);
	particle.SetTemperature(particle.temperatureStartFrame);
	particles[id.x] = particle;
}

[numthreads(BINS_THREAD_COUNT, 1, 1)]
void InitBins(uint3 id : SV_DispatchThreadID) {
	Bin bin = bins[id.x];
	bin.id = id.x;
	bin.posX = ConvertBinIDToBinPosX(id.x);
	bin.posY = ConvertBinIDToBinPosY(id.x);
	bins[id.x] = bin;
}

[numthreads(BINS_THREAD_COUNT, 1, 1)]
void CacheBinStates(uint3 id : SV_DispatchThreadID){
	binsAtStartFrame[id.x] = bins[id.x];
}

// called continuosly
[numthreads(OUTPUT_THREAD_COUNT_X, OUTPUT_THREAD_COUNT_Y, 1)]
void ClearOutputTexture(uint3 id : SV_DispatchThreadID) {
	output[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
}

[numthreads(BINS_THREAD_COUNT, 1, 1)]
void CacheParticlesInBins(uint3 id : SV_DispatchThreadID){
	Bin bin = bins[id.x];
	if(!isFirstFrame){
		if(bin.isDirty == 0){
			return;
		}
	}
	

	uint binLoad = 0;
	uint binContents[BIN_MAX_AMOUNT_OF_CONTENT] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
	if(isFirstFrame){
		for(uint i = 0; i < particleCount; i++){
			Particle particle = particles[i];
			if(particle.binID == bin.id){
				binContents[binLoad] = i;
				binLoad += 1;
			}

			if(binLoad >= BIN_MAX_AMOUNT_OF_CONTENT){
				break;
			}
		}
	}
	else{
		uint clusterLoad;
		uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
		GetNeighboringParticles(bin.posX, bin.posY, true, clusterLoad, clusterContents);

		for(uint i = 0; i < clusterLoad; i++){
			int particleIndex = clusterContents[i];	
			Particle particle = particles[particleIndex];

			if(particle.binID == bin.id){
				binContents[binLoad] = particleIndex;
				binLoad += 1;

				if(binLoad >= BIN_MAX_AMOUNT_OF_CONTENT){
					break;
				}
			}
		}
	}

	bin.isDirty = 0;
	bin.load = binLoad;
	bin.contents = binContents;
	bins[id.x] = bin;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void CacheParticleNeighbors(uint3 id : SV_DispatchThreadID){
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint2 binPos = uint2(ConvertBinIDToBinPosX(particle.binID), ConvertBinIDToBinPosY(particle.binID));

	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(binPos.x, binPos.y, false, clusterLoad, clusterContents);

	particle.clusterLoad = clusterLoad;
	particle.clusterContents = clusterContents;

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeDensity(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}


	uint clusterLoad = particle.clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX] = particle.clusterContents;
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	// uint clusterLoad;
	// uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	particle.density = particle.GetMass() * POLY6 * pow(HSQ, 2.0);
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];
		float2 dir = otherParticle.pos - particle.pos;
		float r2 = (dir.x * dir.x + dir.y * dir.y) * max(particle.repelFactor, otherParticle.repelFactor);

		half areParticlesDifferent = signAbs(id.x - neighborIndex);
		half shouldApplyDensity = areParticlesDifferent * step(r2, HSQ);
		particle.density += shouldApplyDensity * otherParticle.GetMass() * POLY6 * pow(HSQ - r2, 2.0);
	}

	particles[id.x] = particle;
	
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputePressure(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	particle.pressure = particle.isActive * GAS_CONST * (particle.density - REST_DENS);
	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeHeat(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad = particle.clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX] = particle.clusterContents;
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	// uint clusterLoad;
	// uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	particle.debugTemp = 0.0;
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];
		float2 dir = otherParticle.pos - particle.pos;
		float r2 = (dir.x * dir.x + dir.y * dir.y) * max(particle.repelFactor, otherParticle.repelFactor);

		half areParticlesDifferent = signAbs(id.x - neighborIndex);
		half shouldApplyDensity = areParticlesDifferent * step(r2, HSQ);

		half temperatureStartFrame = particle.temperatureStartFrame;
		half temperatureStartFrameOther = otherParticle.temperatureStartFrame;
		
		half isWithinRange = step(r2, HSQ_TEMPERATURE);
		if(isWithinRange && neighborIndex == debugIndex && otherParticle.binID == particle.binID){
			particle.debugTemp = 1.0;
		}

		half isWarmerThanNeighbor = step(temperatureStartFrameOther, temperatureStartFrame);
		half isNeighborBelowMaxHeat = step(otherParticle.temperatureStartFrame, MAX_TEMPERATURE);
		half shouldApplyTemperature = isWarmerThanNeighbor * areParticlesDifferent * isWithinRange * isNeighborBelowMaxHeat;

		half thermalDiffusivity = (particle.GetThermalDiffusivity() + otherParticle.GetThermalDiffusivity()) * 0.5;
		half exchangeGive = shouldApplyTemperature * (temperatureStartFrame - temperatureStartFrameOther) * thermalDiffusivity;

		half4 particlesToHeat = particle.particlesToHeat;
		half4 heatToGive = particle.heatToGive; 

		if(exchangeGive > heatToGive.w){
			heatToGive.x = heatToGive.y;
			heatToGive.y = heatToGive.z;
			heatToGive.z = heatToGive.w;
			heatToGive.w = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = particlesToHeat.z;
			particlesToHeat.z = particlesToHeat.w;
			particlesToHeat.w = neighborIndex;
		}
		else if(exchangeGive > heatToGive.z){
			heatToGive.x = heatToGive.y;
			heatToGive.y = heatToGive.z;
			heatToGive.z = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = particlesToHeat.z;
			particlesToHeat.z = neighborIndex;
		}
		else if(exchangeGive > heatToGive.y){
			heatToGive.x = heatToGive.y;
			heatToGive.y = exchangeGive;

			particlesToHeat.x = particlesToHeat.y;
			particlesToHeat.y = neighborIndex;
		}
		else if(exchangeGive > heatToGive.x){
			heatToGive.x = exchangeGive;
			particlesToHeat.x = neighborIndex;
		}

		particle.particlesToHeat = particlesToHeat;
		particle.heatToGive = heatToGive;
	}

	// clamp components
	half4 heatToGive = particle.heatToGive;
	half heat = particle.temperatureStartFrame;
	heatToGive.x = min(heatToGive.x, heat);
	heatToGive.y = min(heatToGive.y, heat - heatToGive.x);
	heatToGive.z = min(heatToGive.z, heat - (heatToGive.x + heatToGive.y));
	heatToGive.w = min(heatToGive.w, heat - (heatToGive.x + heatToGive.y + heatToGive.z));
	
	particle.heatToGive = heatToGive;

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ApplyHeat(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad = particle.clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX] = particle.clusterContents;
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	// uint clusterLoad;
	// uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	half heat = particle.temperatureStartFrame;
	
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];

		Particle otherParticle = particles[neighborIndex];

		uint4 othersParticlesToHeat = otherParticle.particlesToHeat;
		half isParticleX = 1 - signAbs(othersParticlesToHeat.x - id.x);
		half isParticleY = 1 - signAbs(othersParticlesToHeat.y - id.x);
		half isParticleZ = 1 - signAbs(othersParticlesToHeat.z - id.x);
		half isParticleW = 1 - signAbs(othersParticlesToHeat.w - id.x);

		half4 othersHeatToGive = otherParticle.heatToGive; 
		heat += othersHeatToGive.x * isParticleX;
		heat += othersHeatToGive.y * isParticleY;
		heat += othersHeatToGive.z * isParticleZ;
		heat += othersHeatToGive.w * isParticleW;
	}

	half4 heatToGive = particle.heatToGive;
	particle.SetTemperature(heat - (heatToGive.x + heatToGive.y + heatToGive.z + heatToGive.w));

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	uint clusterLoad = particle.clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX] = particle.clusterContents;
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	// uint clusterLoad;
	// uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	// GetNeighboringParticles(particle.binPosX, particle.binPosY, clusterLoad, clusterContents);

	float2 fpress = float2(0.0, 0.0);
	float2 fvisc = float2(0.0, 0.0);
	float2 fsurftens = float2(0.0, 0.0);
	float2 fgrav = G * particle.density;
	
	for (uint i = 0; i < clusterLoad; i++){
		uint neighborIndex = clusterContents[i];
	
		Particle otherParticle = particles[neighborIndex];

		float2 diff = PreventValueBeingZero(otherParticle.pos - particle.pos);
		float2 diffNormal = normalize(diff);

		float r = sqrt(diff.x * diff.x + diff.y * diff.y) * max(particle.repelFactor, otherParticle.repelFactor);

		uint areParticlesDifferent = signAbs(id.x - neighborIndex);
		uint isTouchingNeighbor = step(r, H);
		uint shouldApplyAnything = areParticlesDifferent * particle.isActive * otherParticle.isActive;

		// compute pressure force contribution
		fpress += shouldApplyAnything * isTouchingNeighbor * -diffNormal * otherParticle.GetMass() * (particle.pressure + otherParticle.pressure) / (2.0 * otherParticle.density) * SPIKY_GRAD * pow(H - r, 2.0) * CLUSTERING_RESISTANCE;
		// compute viscosity force contribution
		fvisc += shouldApplyAnything * isTouchingNeighbor * otherParticle.GetViscosity() * otherParticle.GetMass() * (otherParticle.velocity - particle.velocity) / otherParticle.density * VISC_LAP * (H - r);
		
		float shouldApplySurfaceTension = shouldApplyAnything * floor((step(r, H_SURFACE_TENSION) + particle.IsLiquid()) * 0.5);
		fsurftens += shouldApplySurfaceTension * diffNormal * VISC_LAP * SURFACE_TENSION_WATER;

		// bounce off frozen particles
		float shouldApplyBounce = shouldApplyAnything * isTouchingNeighbor * floor((isTouchingNeighbor + otherParticle.IsSolid()) / 2.0);
		particle.velocity *= lerp(1.0, diffNormal * BOUND_DAMPING, shouldApplyBounce);
	}

	particle.force = particle.isActive * (fpress + fvisc + fsurftens + fgrav);

	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	if(particle.isActive == 0){
		return;
	}

	particle.force.x = PreventValueBeingZero(particle.force.x);
	particle.force.y = PreventValueBeingZero(particle.force.y);
	particle.density = PreventValueBeingZero(particle.density);

	// forward Euler integration
	particle.velocity += DT * (particle.force / particle.density);
	particle.pos += DT * particle.velocity;

	// if(isFirstFrame) particle.velocity += (particle.force / particle.GetMass()) * DT * 0.5;
	// particle.pos += DT * particle.velocity;
	// float2 acceleration = particle.force / particle.GetMass();
	// particle.velocity += DT * acceleration;

	float oldX = particle.pos.x;
	float oldY = particle.pos.y;
	particle.pos.x = clamp(particle.pos.x, EPS, GRID_WIDTH_PIXELS - EPS);
	particle.pos.y = clamp(particle.pos.y, EPS, GRID_HEIGHT_PIXELS - EPS);

	particle.velocity.x *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.x - oldX)), 0, 1));
	particle.velocity.y *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.y - oldY)), 0, 1));
	// velocity = particle.velocity;

	float temp = (particle.temperature / MAX_TEMPERATURE);
	// output[particle.pos] = float4(temp, 0, 1 - temp, particle.isActive);
	// output[particle.pos] = float4(0, 1, 0, particle.isActive);
	// output[particle.pos] = float4(0, 0, 0, 1);
	// output[particle.pos] = float4(particle.IsSolid(), particle.IsLiquid(), particle.IsGas(), 1);


	 // for next frame
	 uint oldBinID = particle.binID;
	 particle.binID = GetBinIDFromPos(particle.pos);

	if(particle.binID != oldBinID){
		bins[oldBinID].isDirty = 1;
		bins[particle.binID].isDirty = 1;
	}

	particle.temperatureStartFrame = particle.temperature;
	particle.particlesToHeat.xyzw = 0.0;
	particle.heatToGive.xyzw = 0.0;

	particles[id.x] = particle;
}

[numthreads(BINS_THREAD_COUNT, 1, 1)]
void MarkPixelsForPostProcess(uint3 id : SV_DispatchThreadID){
	Bin bin = bins[id.x];

	uint clusterLoad;
	uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	GetNeighboringParticles(bin.posX, bin.posY, false, clusterLoad, clusterContents);
	if(clusterLoad == 0) return;

	uint posX = bin.posX * BIN_SIZE;
	uint posY = bin.posY * BIN_SIZE;

	for(uint i = 0; i < BIN_PIXEL_COUNT; i++){
		uint pixelLocalY = floor(i / float(BIN_SIZE));
		uint pixelLocalX = i - pixelLocalY * BIN_SIZE;
		uint2 pixelPos = uint2(posX + pixelLocalX, posY + pixelLocalY);

		half result = 0.0;
		for(uint i1 = 0; i1 < clusterLoad; i1++){
			Particle particle = particles[clusterContents[i1]];
			half repelFactor = particle.repelFactor;
			
			float r2 = repelFactor * REPEL_STRENGTH_MAX;
			float2 dir = particle.pos - pixelPos;
			result += (r2 / ((dir.x * dir.x + dir.y * dir.y) * repelFactor * 1.0)) - 0.75;
		}

		output[pixelPos] = float4(0.0, result, 0.0, 1.0);
		// output[pixelPos] = float4(clusterLoad / 10.0, result, bin.load / 10.0, 1.0);
	}
}

[numthreads(POSTPROCESS_THREAD_COUNT_X, POSTPROCESS_THREAD_COUNT_Y, 1)]
void PostProcess(uint3 id : SV_DispatchThreadID){
	// float4 pixel = output[id.xy];
	// if(pixel.r < 1.0) return;

	// uint clusterLoad;
	// uint clusterContents[BIN_CLUSTER_CONTENT_MAX];
	// GetNeighboringParticles(ConvertPosToBinPosX(id.xy), ConvertPosToBinPosY(id.xy), false, clusterLoad, clusterContents);
	// if (clusterLoad == 0) return;

	// half result = 1.0;// bin.load / half(BIN_MAX_AMOUNT_OF_CONTENT * 0.5);
	
	// for(uint i = 0; i < clusterLoad; i++){
	// 	Particle particle = particles[clusterContents[i]];
	// 	half repelFactor = particle.repelFactor;
		
	// 	float r2 = repelFactor * REPEL_STRENGTH_MAX;
	// 	float2 dir = particle.pos - id.xy;
	// 	result += (r2 / ((dir.x * dir.x + dir.y * dir.y)));// * repelFactor));// - 0.5;
	// }

	// output[id.xy] = float4(0, result, 0, 1);
	// output[id.xy] = float4(1, 0, 0, 1);
}