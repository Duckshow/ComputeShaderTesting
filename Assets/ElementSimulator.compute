#pragma kernel ClearOutputTexture
#pragma kernel ComputeDensityAndPressure
#pragma kernel ComputeForces
#pragma kernel Integrate


// solver parameters
static const float2 G = float2(600 * -9.8, 600 * -9.8); // external (gravitational) forces
static const float REST_DENS = 1000; // rest density
static const float GAS_CONST = 2000; // const for equation of state
static const float H = 0.5; // interaction radius
static const float HSQ = H * H; // radius^2 for optimization
static const float HSQ_TEMPERATURE = HSQ * 2.0; // interaction radius
static const float H_SURFACE_TENSION = H * 3.0; // interaction radius
static const float MASS = 2.0; // assume all particles have the same mass
static const float VISC = 250.0; // viscosity constant
static const float DT = 0.0008;// 0.0008; // integration timestep
static const float DENSITY_OFFSET = 0.925; // make SPIKY_GRAD apply force earlier (particles don't have to be as close)
static const float VISC_OFFSET = 0.925; // make VISC_LAP apply force earlier (particles don't have to be as close)
static const float PI = 3.14159265359;
// smoothing kernels defined in Müller and their gradients
static const float POLY6 = 315.0 / (65.0 * PI * pow(H, 9.0));
static const float SPIKY_GRAD = -45.0 / (PI * pow(H * DENSITY_OFFSET, 6.0));
static const float VISC_LAP = 45.0 / (PI * pow(H * VISC_OFFSET, 6.0));

// simulation parameters
static const float EPS = H; // boundary epsilon
static const float BOUND_DAMPING = -0.5;
static const int DAM_PARTICLES_L = 100;
static const int DAM_PARTICLES_R = 100;
static const int MAX_PARTICLES = 2000;

static const float MIN_TIME_BETWEEN_PARTICLE_SPAWN = 0.1;
static const float MAX_TEMPERATURE = 1000.0;

static const float THERMAL_DIFFUSIVITY = 0.5;
static const float REPEL_STRENGTH_MIN = 1.0;
static const float REPEL_STRENGTH_MAX = 8.0;
static const float REPEL_FACTOR_MIN = 1.0 / REPEL_STRENGTH_MAX;
static const float REPEL_FACTOR_MAX = 1.0 / REPEL_STRENGTH_MIN;
static const float CLUSTERING_RESISTANCE = 1.0;
static const float SURFACE_TENSION_WATER = 5.0;

static const float STATE_CORRECTION_OFFSET = 0.000001; // offset to ensure two states can't be == 1 at the same time
static const float REPEL_STRENGTH_SMOOTHING_START_SOLID = 0.9;

static const float ALMOST_BUT_NOT_QUITE_ZERO = 0.00001; // used to prevent division by zero

//#region[rgba(80, 0, 0, 1)] | WARNING: shared with ElementSimulator.cs! must be equal!
static const int OUTPUT_THREAD_COUNT_X = 32;
static const int OUTPUT_THREAD_COUNT_Y = 32;

static const int THREAD_COUNT_X = 64;
static const uint PIXELS_PER_TILE_EDGE = 32;
static const uint GRID_WIDTH_TILES = 1;
static const uint GRID_HEIGHT_TILES = 1;
static const uint GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const uint GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
static const uint BIN_WIDTH = 1;
static const uint BIN_COUNT_X = (GRID_WIDTH_PIXELS / BIN_WIDTH) / 2;
static const uint BIN_COUNT_Y = (GRID_HEIGHT_PIXELS / BIN_WIDTH) / 2;
static const uint BIN_MAX_AMOUNT_OF_CONTENT = 64;
//#endregion

static const uint BIN_CLUSTER_SIZE = 9;
static const uint BIN_CLUSTER_CONTENT_MAX = BIN_CLUSTER_SIZE * BIN_MAX_AMOUNT_OF_CONTENT;


static const int ELEMENT_COUNT = 1;

static const float Mass[ELEMENT_COUNT] = { 
	MASS * 1.0 
};
static const float Viscosity[ELEMENT_COUNT] = {
	VISC * 1.0
};
static const float TemperatureFreezingPoint[ELEMENT_COUNT] = {
	273.15
};
static const float TemperatureBoilingPoint[ELEMENT_COUNT] = {
	373.15
};
static const float RepelStrengthSolid[ELEMENT_COUNT] = {
	1.75
};
static const float RepelStrengthLiquid[ELEMENT_COUNT] = {
	1.5
};
static const float RepelStrengthGas[ELEMENT_COUNT] = {
	2.0
};
static const float ThermalDiffusivitySolid[ELEMENT_COUNT] = {
	1.0
};
static const float ThermalDiffusivityLiquid[ELEMENT_COUNT] = {
	0.75
};
static const float ThermalDiffusivityGas[ELEMENT_COUNT] = {
	0.5
};


uint4 scale(uint4 f1, uint4 f2){
	return uint4(f1.x * f2.x, f1.y * f2.y, f1.z * f2.z, f1.w * f2.w);
}

int signNotZero(float f){
	int fSignActual = sign(f);
	return lerp(1, fSignActual, abs(fSignActual));
}

int sign01(float f){
	return clamp(sign(f), 0, 1);
}

int signAbs(float f){
	return abs(sign(f));
}

float PreventValueBeingZero(float f){
	return max(ALMOST_BUT_NOT_QUITE_ZERO, abs(f)) * signNotZero(f);
}

float2 PreventValueBeingZero(float2 f2){
	return float2(PreventValueBeingZero(f2.x), PreventValueBeingZero(f2.y));
}

struct Particle{ // WARNING: variables must correspond to ElementSimulator.cs's Particle
	float2 pos;
	float2 velocity; 
	float2 force;

	float density;
	float pressure;
	float temperature;
	float temperatureStartFrame;
	float repelFactor;
	half isActive; // every thread needs a particle, so some will get inactive particles instead
	uint elementIndex;
	float debug1;
	float debug2;
	float debug3;
	float debug4;
	float debug5;

	float IsSolid() {
		return step(temperature, GetFreezingPoint() + STATE_CORRECTION_OFFSET);
	}

	float IsLiquid() {
		return step(temperature, GetBoilingPoint() - STATE_CORRECTION_OFFSET) - IsSolid();
	}

	float IsGas() {
		return step(temperature, GetBoilingPoint() + STATE_CORRECTION_OFFSET);
	}

	float GetThermalDiffusivity() {
		return 0.7;//THERMAL_DIFFUSIVITY * ((IsSolid() * GetThermalDiffusivitySolid()) + (IsLiquid() * GetThermalDiffusivityLiquid()) + (IsGas() * GetThermalDiffusivityGas()));
	}

	float GetMass()						{ return Mass[elementIndex]; }
	float GetViscosity()				{ return Viscosity[elementIndex]; }
	float GetFreezingPoint()			{ return TemperatureFreezingPoint[elementIndex]; }
	float GetBoilingPoint()				{ return TemperatureBoilingPoint[elementIndex]; }
	float GetRepelStrengthSolid()		{ return RepelStrengthSolid[elementIndex]; }
	float GetRepelStrengthLiquid()		{ return RepelStrengthLiquid[elementIndex]; }
	float GetRepelStrengthGas()			{ return RepelStrengthGas[elementIndex]; }
	float GetRepelStrengthCurrent()		{ return IsSolid() * GetRepelStrengthSolid() + IsLiquid() * GetRepelStrengthLiquid() + IsGas() * GetRepelStrengthGas(); }
	float GetThermalDiffusivitySolid()	{ return ThermalDiffusivitySolid[elementIndex]; }
	float GetThermalDiffusivityLiquid()	{ return ThermalDiffusivityLiquid[elementIndex]; }
	float GetThermalDiffusivityGas()	{ return ThermalDiffusivityGas[elementIndex]; }

	void SetTemperature(float temp){
		temperature = temp;// clamp(temp, 0.0, MAX_TEMPERATURE);

		float isSolid = IsSolid();
		float isLiquid = IsLiquid();
		float isGas = IsGas();

		float repelStrengthSolid = GetRepelStrengthSolid();
		float repelStrengthLiquid = GetRepelStrengthLiquid();
		float repelStrengthGas = GetRepelStrengthGas();

		// to prevent melting causing explosions, lerp the repelstrength
		float repelStrengthSmoothedSolidToLiquid = lerp(repelStrengthSolid, repelStrengthLiquid, (temp - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetFreezingPoint() - GetFreezingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID));
		float repelStrengthSmoothedLiquidToGas = lerp(repelStrengthLiquid, repelStrengthGas, (temp - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID) / (GetBoilingPoint() - GetBoilingPoint() * REPEL_STRENGTH_SMOOTHING_START_SOLID));

		// each state has a fixed strength, but gas continues the more temperature increases
		repelFactor = 0.0;
		repelFactor += (1.0 / repelStrengthSmoothedSolidToLiquid) * isSolid;
		repelFactor += (1.0 / repelStrengthSmoothedLiquidToGas) * isLiquid;
		repelFactor += (1.0 / repelStrengthGas) * isGas;

		float extraRepelFactor = 1.0 / clamp(max(REPEL_STRENGTH_MIN, temperature / MAX_TEMPERATURE * REPEL_STRENGTH_MAX), REPEL_STRENGTH_MIN, REPEL_STRENGTH_MAX);
		repelFactor += (extraRepelFactor - repelFactor) * isGas;

		repelFactor = clamp(repelFactor, REPEL_FACTOR_MIN, REPEL_FACTOR_MAX); // just a safeguard
	}
};


RWStructuredBuffer<Particle> particles;
uint particleCount;

RWTexture2D<float4> binLoads; // TODO: investigate registers further, to see how variables can be shared between dispatches
RWTexture2DArray<float4> binContents;
RWTexture2D<float4> output;


// void CorrectBinPosForQuadrants(inout uint2 pos, out uint4 gridQuadrant){
// 	uint gridQuadrantX = floor(pos.x / BIN_COUNT_X);
// 	uint gridQuadrantY = floor(pos.y / BIN_COUNT_Y);

// 	pos.x -= gridQuadrantX * BIN_COUNT_X;
// 	pos.y -= gridQuadrantY * BIN_COUNT_Y;

// 	gridQuadrant.x = 1 - gridQuadrantX;
// 	gridQuadrant.y = 1 - gridQuadrantY;
// 	gridQuadrant.z = gridQuadrantX;
// 	gridQuadrant.w = gridQuadrantY;
// }

// void GetBinCoordinates(float2 pos, out uint2 binPos, out uint4 gridQuadrant) {
// 	binPos.x = floor(pos.x / BIN_WIDTH);
// 	binPos.y = floor(pos.y / BIN_WIDTH);
// 	CorrectBinPosForQuadrants(binPos, gridQuadrant);
// }

// void AddBinContentsToNeighbors(uint2 binPos, inout uint nIndex, inout uint neighbors[MAX_AMOUNT_OF_NEIGHBORS]){
// 	uint isXGreaterThanOrEqualToZero = clamp(sign(binPos.x), 0, 1);
// 	uint isXLessThanMax = clamp(sign(BIN_COUNT_X * 2 - binPos.x), 0, 1);
// 	uint isYGreaterThanOrEqualToZero = clamp(sign(binPos.y), 0, 1);
// 	uint isYLessThanMax = clamp(sign(BIN_COUNT_Y * 2 - binPos.y), 0, 1);
// 	uint isXAndYWithinGrid = floor((isXGreaterThanOrEqualToZero + isYGreaterThanOrEqualToZero + isXLessThanMax + isYLessThanMax) * 0.25);

// 	uint4 gridQuadrant;
// 	CorrectBinPosForQuadrants(binPos, gridQuadrant);

// 	uint4 relevantBinLoads = scale(binLoads[binPos], gridQuadrant);
// 	uint addingAmount = isXAndYWithinGrid * (relevantBinLoads.r + relevantBinLoads.g + relevantBinLoads.b + relevantBinLoads.a);
// 	for (uint i = 0; i < addingAmount; i++){
// 		uint4 neighborContent = binContents[uint3(binPos.x, binPos.y, i)] * gridQuadrant;
// 		neighbors[nIndex] = neighborContent.x + neighborContent.y + neighborContent.z + neighborContent.w;
// 		nIndex++;
// 	}
// }

// int GetNeighborParticleIndices(float2 pos, out uint neighbors[MAX_AMOUNT_OF_NEIGHBORS]) {
// 	uint2 binPos;
// 	uint4 gridQuadrant;
// 	uint nIndex = 0;
// 	GetBinCoordinates(pos, binPos, gridQuadrant);
// 	// AddBinContentsToNeighbors(uint2(binPos.x - 1, binPos.y + 1), 	nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x, 	 binPos.y + 1), 	nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x + 1, binPos.y + 1), 	nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x - 1, binPos.y), 		nIndex, neighbors);
// 	AddBinContentsToNeighbors(uint2(binPos.x, 	 binPos.y), 		nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x + 1, binPos.y), 		nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x - 1, binPos.y - 1), 	nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x, 	 binPos.y - 1), 	nIndex, neighbors);
// 	// AddBinContentsToNeighbors(uint2(binPos.x + 1, binPos.y - 1), 	nIndex, neighbors);
	
// 	return nIndex;
// }

// void CacheParticleInBin(uint pIndex) {
// 	uint2 binPos;
// 	uint4 gridQuadrant; // only 1 component == 1, to indicate which corner of the grid we're in (BL, TL, BR, TR)
// 	GetBinCoordinates(particles[pIndex].pos, binPos, gridQuadrant);
	
// 	uint4 binLoad = binLoads[binPos];
// 	uint binContentIndex = binLoad.x * gridQuadrant.x + binLoad.y * gridQuadrant.y + binLoad.z * gridQuadrant.z + binLoad.w * gridQuadrant.w; 
// 	binLoad += gridQuadrant; 

// 	uint3 exactBinPos = uint3(binPos.x, binPos.y, binContentIndex);
// 	uint4 contents = binContents[exactBinPos];
// 	contents.x = lerp(contents.x, pIndex, gridQuadrant.x);
// 	contents.y = lerp(contents.y, pIndex, gridQuadrant.y);
// 	contents.z = lerp(contents.z, pIndex, gridQuadrant.z);
// 	contents.w = lerp(contents.w, pIndex, gridQuadrant.w);
// 	binContents[exactBinPos] = contents;
// }

[numthreads(OUTPUT_THREAD_COUNT_X, OUTPUT_THREAD_COUNT_Y, 1)]
void ClearOutputTexture(uint3 id : SV_DispatchThreadID) {
	output[id.xy] = float4(0, 0, 0, 0);
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeDensityAndPressure(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];

	//	CacheParticleInBin(id.x);

	// uint neighborIndices[BIN_CLUSTER_SIZE * BIN_MAX_AMOUNT_OF_CONTENT];
	// uint neighborCount = GetNeighborParticleIndices(particle.pos, neighborIndices);

	half density = 0.0;
	half temperatureToGive = particle.temperature;

	//uint i2 = 0, i = 1 - id.x;
	for (uint i2 = 0, i = id.x; i2 < particleCount; i2++, i = (i + 1) % particleCount){
		uint neighborIndex = i;// neighborIndices[i2];

		Particle otherParticle = particles[neighborIndex];
		float2 dir = otherParticle.pos - particle.pos;
		float r2 = (dir.x * dir.x + dir.y * dir.y) * max(particle.repelFactor, otherParticle.repelFactor);

		half areBothParticlesActive = particle.isActive * otherParticle.isActive;
		half shouldApplyDensity = areBothParticlesActive * step(r2, HSQ);
		density += shouldApplyDensity * otherParticle.GetMass() * POLY6 * pow(HSQ - r2, 2.0);

		half temperature = particle.temperature;
		half temperatureOther = otherParticle.temperature;
		half temperatureStartFrame = particle.temperatureStartFrame;
		half temperatureStartFrameOther = otherParticle.temperatureStartFrame;
		half areParticlesDifferent = signAbs(id.x - i);
		half isWithinRange = step(r2, HSQ_TEMPERATURE);
		half isWarmerThanNeighbor = step(temperatureStartFrameOther, temperatureStartFrame);
		half shouldApplyTemperature = isWarmerThanNeighbor * areParticlesDifferent * areBothParticlesActive * isWithinRange;
		half exchangeGive = shouldApplyTemperature * (temperatureStartFrame - temperatureStartFrameOther) * particle.GetThermalDiffusivity(); // TODO: instead of using one Thermal Diffusivity, perhaps use the average of both?
		exchangeGive = min(temperatureToGive, exchangeGive);
		temperatureToGive -= exchangeGive;
		
		otherParticle.SetTemperature(temperatureOther + exchangeGive);
		particles[neighborIndex] = otherParticle;
		
		if(otherParticle.isActive > 0 && areParticlesDifferent > 0){
			particles[id.x].debug1 = temperatureOther;
			particles[id.x].debug2 = exchangeGive;
		}
	}

	particle = particles[id.x];
	particle.debug3 = particle.temperature;
	particle.debug4 = particle.temperatureStartFrame;
	particle.debug5 = temperatureToGive;

	particle.density = max(ALMOST_BUT_NOT_QUITE_ZERO, density);
	particle.SetTemperature(particle.temperature - (particle.temperatureStartFrame - temperatureToGive));
	particle.pressure = particle.isActive * GAS_CONST * (particle.density - REST_DENS);
	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void ComputeForces(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];
	float2 fpress = float2(0.0, 0.0);
	float2 fvisc = float2(0.0, 0.0);
	float2 fsurftens = float2(0.0, 0.0);
	// int neighborIndices[BUCKET_CLUSTER_SIZE * BUCKET_MAX_AMOUNT_OF_CONTENT];
	// int neighborCount = GetNeighborParticleIndices(particle.pos, neighborIndices);
	//int i2 = id.x;
	for (uint i2 = 0; i2 < particleCount; i2++){
		int neighborIndex = i2;// neighborIndices[i2];

		Particle otherParticle = particles[neighborIndex];
		float2 diff = PreventValueBeingZero(otherParticle.pos - particle.pos);
		float2 diffNormal = normalize(diff);

		float r = sqrt(diff.x * diff.x + diff.y * diff.y) * max(particle.repelFactor, otherParticle.repelFactor);

		uint areParticlesDifferent = signAbs(id.x - i2); // remove if binning is implemented
		uint isTouchingNeighbor = step(r, H);
		uint shouldApplyAnything = isTouchingNeighbor * areParticlesDifferent * particle.isActive * otherParticle.isActive;

		// compute pressure force contribution
		fpress += shouldApplyAnything * -diffNormal * otherParticle.GetMass() * (particle.pressure + otherParticle.pressure) / (2.0 * otherParticle.density) * SPIKY_GRAD * pow(H - r, 2.0) * CLUSTERING_RESISTANCE;
		// compute viscosity force contribution
		fvisc += shouldApplyAnything * otherParticle.GetViscosity() * otherParticle.GetMass() * (otherParticle.velocity - particle.velocity) / otherParticle.density * VISC_LAP * (H - r);
		
		// bounce off frozen particles
		float shouldApplyBounce = shouldApplyAnything * floor((isTouchingNeighbor + otherParticle.IsSolid()) / 2.0);
		particle.velocity.x *= lerp(1.0, diffNormal.x * BOUND_DAMPING, shouldApplyBounce);
		particle.velocity.y *= lerp(1.0, diffNormal.y * BOUND_DAMPING, shouldApplyBounce);

		float shouldApplySurfaceTension = shouldApplyAnything * floor((step(r, H_SURFACE_TENSION) + particle.IsLiquid()) * 0.5);
		fsurftens += shouldApplySurfaceTension * diffNormal * VISC_LAP * SURFACE_TENSION_WATER;
	}

	float2 fgrav = G * particle.density;
	particle.force = particle.isActive * (fpress + fvisc + fgrav + fsurftens);

	particle.temperatureStartFrame = particle.temperature; // for next frame
	particles[id.x] = particle;
}

[numthreads(THREAD_COUNT_X, 1, 1)]
void Integrate(uint3 id : SV_DispatchThreadID) {
	Particle particle = particles[id.x];

	particle.force.x = PreventValueBeingZero(particle.force.x);
	particle.force.y = PreventValueBeingZero(particle.force.y);
	particle.density = PreventValueBeingZero(particle.density);

	// forward Euler integration
	particle.velocity += DT * (particle.force / particle.density);
	particle.pos += DT * particle.velocity;

	// enforce boundary conditions
	// int hasHitEdge = 0;
	// if (particle.pos.x - EPS < 0.0){
	// 	particle.velocity.x *= BOUND_DAMPING;
	// 	particle.pos.x = EPS;
	// 	hasHitEdge = 1;
	// }
	// if (particle.pos.x + EPS > GRID_WIDTH_PIXELS){
	// 	particle.velocity.x *= BOUND_DAMPING;
	// 	particle.pos.x = GRID_WIDTH_PIXELS - EPS;
	// 	hasHitEdge = 1;
	// }
	// if (particle.pos.y - EPS < 0.0){
	// 	particle.velocity.y *= BOUND_DAMPING;
	// 	particle.pos.y = EPS;
	// 	hasHitEdge = 1;
	// }
	// if (particle.pos.y + EPS > GRID_HEIGHT_PIXELS){
	// 	particle.velocity.y *= BOUND_DAMPING;
	// 	particle.pos.y = GRID_HEIGHT_PIXELS - EPS;
	// 	hasHitEdge = 1;
	// }

	float oldX = particle.pos.x;
	float oldY = particle.pos.y;
	particle.pos.x = clamp(particle.pos.x, EPS, GRID_WIDTH_PIXELS - EPS);
	particle.pos.y = clamp(particle.pos.y, EPS, GRID_HEIGHT_PIXELS - EPS);

	particle.velocity.x *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.x - oldX)), 0, 1));
	particle.velocity.y *= lerp(1.0, BOUND_DAMPING, clamp(ceil(abs(particle.pos.y - oldY)), 0, 1));

	// float temperature = particle.temperature;
	// float diffTemperature = temperature - BOUND_TEMPERATURE;
	// float isBoundaryWarmerThanParticle = clamp(sign(BOUND_TEMPERATURE - temperature), 0, 1);
	// float exchange = diffTemperature;
	// exchange *= lerp(particle.GetThermalDiffusivity(), BOUND_THERMAL_DIFFUSIVITY, isBoundaryWarmerThanParticle);
	// particle.SetTemperature(temperature - exchange * hasHitEdge);


	// if(output[particle.pos].a == 0){ // FIX THIS
	float temp = particle.temperature / MAX_TEMPERATURE;
	//output[particle.pos] = float4(temp, 0, 1 - temp, particle.isActive);// float4(particle.velocity.x * 1000, 0, particle.velocity.y * 1000, particle.isActive);// float4((particle.pos.x / GRID_WIDTH_PIXELS), 0, (particle.pos.y / GRID_HEIGHT_PIXELS), particle.isActive);// float4(0, 0.25, 0.75, particle.isActive);
	output[particle.pos] = float4(particle.temperature, 1 - sign(id.x), 1- particle.temperature, particle.isActive);// float4(particle.velocity.x * 1000, 0, particle.velocity.y * 1000, particle.isActive);// float4((particle.pos.x / GRID_WIDTH_PIXELS), 0, (particle.pos.y / GRID_HEIGHT_PIXELS), particle.isActive);// float4(0, 0.25, 0.75, particle.isActive);

	//} 
	particles[id.x] = particle;
}