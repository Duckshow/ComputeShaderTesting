#pragma kernel Update

struct PixelContent{
	half Element1;
	half Temperature; // keep between 0-10.000(K) (celsius = -273-9727)

	half GetPressure(){
		return Element1 * Temperature; // add Elements, multiply with Temperature
	}
	void SpreadContentTo(PixelContent source, half pressureDiff){
		Element1 += source.Element1 * sign(pressureDiff) * 0.5;
		//Element1 += clamp(source.Element1 * pressureDiff, -Element1, source.Element1);
	}
};

// ============== WARNING: shared with ElementEmulator.cs! must be equal!
static const int PIXELS_PER_TILE_EDGE = 32;
static const int GRID_WIDTH_TILES = 3;
static const int GRID_HEIGHT_TILES = 1;
static const int GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const int GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
//===============

RWStructuredBuffer<PixelContent> pixelsContent;
StructuredBuffer<half2> uvs;
Texture2D<float4> terrainMap;
RWTexture2D<float4> output;


void SortPressureArrayIndices(inout PixelContent neighbors[4], uint i1, uint i2){
	half pMinIndex, pMaxIndex, pDeltaSign;
	PixelContent neighbor1 = neighbors[i1];
	PixelContent neighbor2 = neighbors[i2];

	half p1 = abs(neighbor1.GetPressure());
	half p2 = abs(neighbor2.GetPressure());
	pDeltaSign = sign(p2 - p1);
	pMaxIndex = lerp(i1, i2, pDeltaSign);
	pMinIndex = lerp(i2, i1, pDeltaSign);

	neighbor1 = neighbors[pMaxIndex];
	neighbor2 = neighbors[pMinIndex];
	neighbors[i1] = neighbor1;
	neighbors[i2] = neighbor2;
}
void SortPressureArray(inout PixelContent neighbors[4]){
	for(int i = 0; i < 3; i++){
		for(int index1 = i, index2 = i + 1; index1 >= 0; index1--){
			PixelContent neighbor1 = neighbors[index1];
			PixelContent neighbor2 = neighbors[index2];
			half p1 = abs(neighbor1.GetPressure());
			half p2 = abs(neighbor2.GetPressure());
			half pDeltaSign = sign(p2 - p1);
			half pMaxIndex = lerp(index1, index2, pDeltaSign);
			half pMinIndex = lerp(index2, index1, pDeltaSign);
			neighbor1 = neighbors[pMaxIndex];
			neighbor2 = neighbors[pMinIndex];
			neighbors[index1] = neighbor1;
			neighbors[index2] = neighbor2;
		}
	}
}


[numthreads(32, 32, 1)]
void Update (uint3 id : SV_DispatchThreadID){
	uint2 pixelRelativeToTile = id.xy % PIXELS_PER_TILE_EDGE;
	uint2 tilePos = (id.xy - pixelRelativeToTile) / PIXELS_PER_TILE_EDGE;
	uint2 tilesPerEdge = GRID_WIDTH_PIXELS / PIXELS_PER_TILE_EDGE;
	
	uint uvsIndex = tilesPerEdge.x * tilePos.y + tilePos.x;
	half2 uv = uvs[uvsIndex];
	
	// uint2 terrainMapBottomLeftPixel = uvs[uvsIndex] * terrainMapDimensions;
	// uint2 terrainMapPixel = terrainMapBottomLeftPixel + pixelRelativeToTile;

	uint pixelsContentIndex = (GRID_WIDTH_PIXELS * id.y + id.x);
	uint pixelsContentAbove = pixelsContentIndex + GRID_WIDTH_PIXELS;
	uint pixelsContentBelow = pixelsContentIndex - GRID_WIDTH_PIXELS;
	uint pixelsContentRight = pixelsContentIndex + 1;
	uint pixelsContentLeft = pixelsContentIndex - 1;

	PixelContent content = pixelsContent[pixelsContentIndex];
	PixelContent contentAbove = pixelsContent[pixelsContentAbove];
	PixelContent contentBelow = pixelsContent[pixelsContentBelow];
	PixelContent contentRight = pixelsContent[pixelsContentRight];
	PixelContent contentLeft = pixelsContent[pixelsContentLeft];

	PixelContent neighbors[4] = { contentAbove, contentBelow, contentRight, contentLeft };
	SortPressureArray(neighbors);

	PixelContent neighbor0 = neighbors[0];
	PixelContent neighbor1 = neighbors[1];
	PixelContent neighbor2 = neighbors[2];
	PixelContent neighbor3 = neighbors[3];

	content.SpreadContentTo(neighbor0, neighbor0.GetPressure() - content.GetPressure());
	content.SpreadContentTo(neighbor1, neighbor1.GetPressure() - content.GetPressure());
	content.SpreadContentTo(neighbor2, neighbor2.GetPressure() - content.GetPressure());
	content.SpreadContentTo(neighbor3, neighbor3.GetPressure() - content.GetPressure());

	pixelsContent[pixelsContentIndex] = content;
	output[id.xy] = content.GetPressure();
}