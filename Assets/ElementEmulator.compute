#pragma kernel Update

struct PixelContent{ // WARNING: variables must correspond to ElementEmulator.cs's PixelContent!
	static const half TEMPERATURE_MAX = 10000.0;
	static const half TEMPERATURE_MIN = 0.00001;

	half Element1;
	half Temperature; // keep between 0-10.000(K) (celsius = -273-9727)

	half GetPressure(){
		return Element1 * (Temperature / TEMPERATURE_MAX); // add Elements, multiply with Temperature
	}
	void SpreadContentFrom(PixelContent source, half canReachSource){
		half pressureDiff = source.GetPressure() - GetPressure();
		int giveOrReceive = clamp(sign(pressureDiff), 0, 1);

		Element1 += lerp(Element1, source.Element1, giveOrReceive) * pressureDiff * canReachSource;
	}
};

// ============== WARNING: shared with ElementEmulator.cs! must be equal!
static const uint PIXELS_PER_TILE_EDGE = 32;
static const uint GRID_WIDTH_TILES = 3;
static const uint GRID_HEIGHT_TILES = 1;
static const uint GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const uint GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
static const uint2 TERRAINMAP_SIZE_PIXELS = uint2(96, 32);
//===============

RWStructuredBuffer<PixelContent> pixelsContent;
StructuredBuffer<half2> uvs;
Texture2D<float4> terrainMap;
RWTexture2D<float4> output;


void SortPressureArrayIndices(inout PixelContent neighbors[4], uint i1, uint i2){
	half pMinIndex, pMaxIndex, pDeltaSign;
	PixelContent neighbor1 = neighbors[i1];
	PixelContent neighbor2 = neighbors[i2];

	half p1 = abs(neighbor1.GetPressure());
	half p2 = abs(neighbor2.GetPressure());
	pDeltaSign = sign(p2 - p1);
	pMaxIndex = lerp(i1, i2, pDeltaSign);
	pMinIndex = lerp(i2, i1, pDeltaSign);

	neighbor1 = neighbors[pMaxIndex];
	neighbor2 = neighbors[pMinIndex];
	neighbors[i1] = neighbor1;
	neighbors[i2] = neighbor2;
}
void SortPressureArray(inout PixelContent neighbors[4]){
	for(int i = 0; i < 3; i++){
		for(int index1 = i, index2 = i + 1; index1 >= 0; index1--){
			PixelContent neighbor1 = neighbors[index1];
			PixelContent neighbor2 = neighbors[index2];
			half p1 = abs(neighbor1.GetPressure());
			half p2 = abs(neighbor2.GetPressure());
			half pDeltaSign = sign(p2 - p1);
			half pMaxIndex = lerp(index1, index2, pDeltaSign);
			half pMinIndex = lerp(index2, index1, pDeltaSign);
			neighbor1 = neighbors[pMaxIndex];
			neighbor2 = neighbors[pMinIndex];
			neighbors[index1] = neighbor1;
			neighbors[index2] = neighbor2;
		}
	}
}


[numthreads(32, 32, 1)]
void Update (uint3 id : SV_DispatchThreadID){
	uint2 pixelRelativeToTile = id.xy % PIXELS_PER_TILE_EDGE;
	uint2 tilePos = (id.xy - pixelRelativeToTile) / PIXELS_PER_TILE_EDGE;
	uint2 tilesPerEdge = GRID_WIDTH_PIXELS / PIXELS_PER_TILE_EDGE;
	
	uint uvsIndex = tilesPerEdge.x * tilePos.y + tilePos.x;
	half2 uv = uvs[uvsIndex];
	
	uint2 terrainMapBottomLeftIndex = uvs[uvsIndex] * TERRAINMAP_SIZE_PIXELS;
	uint2 terrainMapIndex = terrainMapBottomLeftIndex + pixelRelativeToTile;
	float4 terrainMapPixel = terrainMap[terrainMapIndex];

	uint pixelsContentIndex = (GRID_WIDTH_PIXELS * id.y + id.x);
	uint pixelsContentAbove = pixelsContentIndex + GRID_WIDTH_PIXELS;
	uint pixelsContentBelow = pixelsContentIndex - GRID_WIDTH_PIXELS;
	uint pixelsContentRight = pixelsContentIndex + 1;
	uint pixelsContentLeft = pixelsContentIndex - 1;

	PixelContent content = pixelsContent[pixelsContentIndex];
	PixelContent contentAbove = pixelsContent[pixelsContentAbove];
	PixelContent contentBelow = pixelsContent[pixelsContentBelow];
	PixelContent contentRight = pixelsContent[pixelsContentRight];
	PixelContent contentLeft = pixelsContent[pixelsContentLeft];

	half canReachAbove = clamp(GRID_HEIGHT_PIXELS - 1 - id.y, 0, 1);
	half canReachBelow = clamp(id.y, 0, 1);
	half canReachRight = clamp(GRID_WIDTH_PIXELS - 1 - id.x, 0, 1);
	half canReachLeft = clamp(id.x, 0, 1);

	content.SpreadContentFrom(contentAbove, canReachAbove);
	content.SpreadContentFrom(contentBelow, canReachBelow);
	content.SpreadContentFrom(contentRight, canReachRight);
	content.SpreadContentFrom(contentLeft, canReachLeft);

	pixelsContent[pixelsContentIndex] = content;
	float4 outputColor = terrainMapPixel;// float4(0, 0, content.Element1, 1);
	output[id.xy] = outputColor;
}