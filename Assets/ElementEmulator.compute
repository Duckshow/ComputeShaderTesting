#pragma kernel Init
#pragma kernel Update

struct PixelContent{ // WARNING: variables must correspond to ElementEmulator.cs's PixelContent!
	static const half TEMPERATURE_MAX = 10000.0;
	static const half TEMPERATURE_MIN = 0.00001;

	half Element1;
	half Temperature; // keep between 0-10.000(K) (celsius = -273-9727)

	half BaseDistribution;
	half4 TerrainMapPixel;
	half2 Wind;


	half IsFreeFromObstacles(){
		return 1 - round(TerrainMapPixel.a);
	}

	void ClearContentIfBlockedByObstacle(){ // Note: Temperature should still be able to spread though
		half isFree = IsFreeFromObstacles();
		Element1 *= isFree;
	}

	half2 GetDistributionMod(){
		return BaseDistribution * (1.0 + Wind);
	}
	
	half GetPressure(half2 directionToThis){
		half2 distribution = GetDistributionMod();
		half distributionX = lerp((BaseDistribution * 2) - distribution.x, distribution.x, clamp(-directionToThis.x, 0, 1)) * abs(directionToThis.x);
		half distributionY = lerp((BaseDistribution * 2) - distribution.y, distribution.y, clamp(-directionToThis.y, 0, 1)) * abs(directionToThis.y);

		return Element1 * (distributionX + distributionY);// * (Temperature / TEMPERATURE_MAX); // add Elements, multiply with Temperature
	}
	
	void SpreadContentFrom(PixelContent source, half canReachSource, half test, half2 directionToSource){
		half pressureDiff = source.GetPressure(directionToSource) - GetPressure(-directionToSource);
		pressureDiff = clamp(pressureDiff, -1, 1);

		Wind += directionToSource * pressureDiff;

		int giveOrReceive = clamp(sign(pressureDiff), 0, 1);
		Element1 += lerp(Element1, source.Element1, giveOrReceive) * pressureDiff * canReachSource;
	}
};

// ============== WARNING: shared with ElementEmulator.cs! must be equal!
static const uint PIXELS_PER_TILE_EDGE = 32;
static const uint GRID_WIDTH_TILES = 3;
static const uint GRID_HEIGHT_TILES = 1;
static const uint GRID_WIDTH_PIXELS = PIXELS_PER_TILE_EDGE * GRID_WIDTH_TILES;
static const uint GRID_HEIGHT_PIXELS = PIXELS_PER_TILE_EDGE * GRID_HEIGHT_TILES;
static const uint2 TERRAINMAP_SIZE_PIXELS = uint2(96, 32);
//===============

RWStructuredBuffer<PixelContent> pixelsContent;
StructuredBuffer<half2> uvs;
Texture2D<float4> terrainMap;
RWTexture2D<float4> output;


uint GetPixelsContentIndex(uint3 id){
	return GRID_WIDTH_PIXELS * id.y + id.x;
}

void GetPixelAndNeighbors(uint pixelsContentIndex, out PixelContent pixel, out PixelContent pixelAbove, out PixelContent pixelBelow, out PixelContent pixelRight, out PixelContent pixelLeft){
	uint indexAbove = pixelsContentIndex + GRID_WIDTH_PIXELS;
	uint indexBelow = pixelsContentIndex - GRID_WIDTH_PIXELS;
	uint indexRight = pixelsContentIndex + 1;
	uint indexLeft = pixelsContentIndex - 1;
	pixel = pixelsContent[pixelsContentIndex];
	pixelAbove = pixelsContent[indexAbove];
	pixelBelow = pixelsContent[indexBelow];
	pixelRight = pixelsContent[indexRight];
	pixelLeft = pixelsContent[indexLeft];
}

void GetCanReachNeighbors(uint3 id, half isPixelFree, half isPixelFreeAbove, half isPixelFreeBelow, half isPixelFreeRight, half isPixelFreeLeft, out half canReachAbove, out half canReachBelow, out half canReachRight, out half canReachLeft){
	canReachAbove = clamp(GRID_HEIGHT_PIXELS - 1 - id.y, 0, 1);
	canReachBelow = clamp(id.y, 0, 1);
	canReachRight = clamp(GRID_WIDTH_PIXELS - 1 - id.x, 0, 1);
	canReachLeft = clamp(id.x, 0, 1);

	canReachAbove = min(canReachAbove, isPixelFree * isPixelFreeAbove);
	canReachBelow = min(canReachBelow, isPixelFree * isPixelFreeBelow);
	canReachRight = min(canReachRight, isPixelFree * isPixelFreeRight);
	canReachLeft  = min(canReachLeft, isPixelFree * isPixelFreeLeft);
}

[numthreads(32, 32, 1)]
void Init(uint3 id : SV_DispatchThreadID){
	uint2 pixelRelativeToTile = id.xy % PIXELS_PER_TILE_EDGE;
	uint2 tilePos = (id.xy - pixelRelativeToTile) / PIXELS_PER_TILE_EDGE;
	uint2 tilesPerEdge = GRID_WIDTH_PIXELS / PIXELS_PER_TILE_EDGE;
	
	uint uvsIndex = tilesPerEdge.x * tilePos.y + tilePos.x;
	half2 uv = uvs[uvsIndex];
	
	uint2 terrainMapBottomLeftIndex = uvs[uvsIndex] * TERRAINMAP_SIZE_PIXELS;
	uint2 terrainMapIndex = terrainMapBottomLeftIndex + pixelRelativeToTile;

	uint pixelsContentIndex = GetPixelsContentIndex(id);
	PixelContent pixel, pixelAbove, pixelBelow, pixelRight, pixelLeft; 
	GetPixelAndNeighbors(pixelsContentIndex, pixel, pixelAbove, pixelBelow, pixelRight, pixelLeft);

	half canReachAbove, canReachBelow, canReachRight, canReachLeft;
	GetCanReachNeighbors(id, pixel.IsFreeFromObstacles(), pixelAbove.IsFreeFromObstacles(), pixelBelow.IsFreeFromObstacles(), pixelRight.IsFreeFromObstacles(), pixelLeft.IsFreeFromObstacles(), canReachAbove, canReachBelow, canReachRight, canReachLeft);
	
	uint amountPixelsInReach = canReachAbove + canReachBelow + canReachRight + canReachLeft;
	pixel.BaseDistribution = 1.0 / amountPixelsInReach;
	pixel.TerrainMapPixel = terrainMap[terrainMapIndex];
	pixel.Element1 *= pixel.IsFreeFromObstacles();
	pixelsContent[pixelsContentIndex] = pixel;
}

[numthreads(32, 32, 1)]
void Update (uint3 id : SV_DispatchThreadID){
	uint pixelsContentIndex = GetPixelsContentIndex(id);
	PixelContent pixel, pixelAbove, pixelBelow, pixelRight, pixelLeft; 
	GetPixelAndNeighbors(pixelsContentIndex, pixel, pixelAbove, pixelBelow, pixelRight, pixelLeft);


	// NOTE: even if Elements can't reach, Temperature should be able to spread, right?
	half canReachAbove, canReachBelow, canReachRight, canReachLeft;
	GetCanReachNeighbors(id, pixel.IsFreeFromObstacles(), pixelAbove.IsFreeFromObstacles(), pixelBelow.IsFreeFromObstacles(), pixelRight.IsFreeFromObstacles(), pixelLeft.IsFreeFromObstacles(), canReachAbove, canReachBelow, canReachRight, canReachLeft);

	half2 axisHorizontal = half2(1, 0);
	half2 axisVertical = half2(0, 1);
	half modVertical = 0.0;
	half modHorizontal = 0.0;
	pixel.SpreadContentFrom(pixelAbove, canReachAbove, modVertical, axisVertical);
	pixel.SpreadContentFrom(pixelBelow, canReachBelow, modVertical, -axisVertical);
	pixel.SpreadContentFrom(pixelRight, canReachRight, modHorizontal, axisHorizontal);
	pixel.SpreadContentFrom(pixelLeft,  canReachLeft, modHorizontal, -axisHorizontal);

	pixelsContent[pixelsContentIndex] = pixel;
	float4 outputColor = float4(pixel.TerrainMapPixel.a, 0, pixel.Element1, 1);
	output[id.xy] = outputColor;
}